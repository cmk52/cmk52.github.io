<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>博客说明</title>
    <url>/2020/04/23/%E5%8D%9A%E5%AE%A2%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<h1 id="第一篇博客"><a href="#第一篇博客" class="headerlink" title="第一篇博客"></a>第一篇博客</h1><ul>
<li><p>博客的一些坑</p>
</li>
<li><p>图片的显示需要安装hexo-asset-image但是得是0.0.5版本要不然显示失败</p>
</li>
<li><p>1.0.0版本在每个图片src前面都会加上/.com的前缀导致加载失败。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">npm install https:<span class="regexp">//gi</span>thub.com<span class="regexp">/CodeFalling/</span>hexo-asset-image --save</span><br></pre></td></tr></table></figure>
<p>使用这个命令才能安装0.0.5版本其它命令都是安装1.0.0会显示错误</p>
</li>
</ul>
]]></content>
      <categories>
        <category>起点</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker</title>
    <url>/2020/04/24/Docker/</url>
    <content><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h1 id="1-Docker简介"><a href="#1-Docker简介" class="headerlink" title="1 Docker简介"></a>1 Docker简介</h1><h2 id="1-1什么是Docker"><a href="#1-1什么是Docker" class="headerlink" title="1.1什么是Docker"></a>1.1什么是Docker</h2><ul>
<li>Docker 是一个开源项目，诞生于 2013 年初，最初是 dotCloud 公司内部的一个业余项目。它基于 Google 公司推出的 Go 语言实现。 项目后来加入了 Linux 基金会，遵从了 Apache 2.0 协议，项目代码在 <a href="https://github.com/docker/docker" target="_blank" rel="noopener">GitHub</a> 上进行维护。</li>
<li><img src="/2020/04/24/Docker/1-3.png" alt><a id="more"></a>
<h2 id="1-2为什么要用Docker"><a href="#1-2为什么要用Docker" class="headerlink" title="1.2为什么要用Docker"></a>1.2为什么要用Docker</h2></li>
<li>要理解这个问题需要了解目前有什么难题出现：<ul>
<li>我们安装软件的时候都是先下载好安装包然后按照步骤按照,但是这样很麻烦如果中间有一步出错那么就会安装失败,但是我们的目的不是安装而是快速搭建好环境然后使用软件</li>
</ul>
</li>
<li>Docker是如何解决这个问题的？<ul>
<li>Docker就如上面的图片一样它承载了许多货物每一个货物就是一个环境(Docker称为镜像)</li>
<li>我们只需要下载镜像然后运行就能够搭建好软件环境,省去了安装步骤。</li>
</ul>
</li>
<li>为什么Docker能解决这个问题？<ul>
<li>下面的图片比较了 Docker 和传统虚拟化方式的不同之处，可见容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，而传统方式则是在硬件层面实现。</li>
<li><img src="/2020/04/24/Docker/1-1(1).png" alt></li>
<li>总的来说就是Docker引擎让安装变的固定化了(去除了它的变量特性,变成常量的)只要是常量就能封装给他人使用。</li>
</ul>
</li>
</ul>
<h1 id="2-Docker安装与启动"><a href="#2-Docker安装与启动" class="headerlink" title="2 Docker安装与启动"></a>2 Docker安装与启动</h1><h2 id="2-1安装Docker"><a href="#2-1安装Docker" class="headerlink" title="2.1安装Docker"></a>2.1安装Docker</h2><p>Docker官方建议在Ubuntu中安装，因为Docker是基于Ubuntu发布的，而且一般Docker出现的问题Ubuntu是最先更新或者打补丁的。在很多版本的CentOS中是不支持更新最新的一些补丁包的。</p>
<p>​    由于我们学习的环境都使用的是CentOS，因此这里我们将Docker安装到CentOS上。注意：这里建议安装在CentOS7.x以上的版本，在CentOS6.x的版本中，安装前需要安装其他很多的环境而且Docker很多补丁不支持更新。</p>
<p>(1) yum包更新到最新</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">sudo yum update</span></span><br></pre></td></tr></table></figure>
<p>(2) 安装需要的软件包，yum-util提供yum-config-manager功能，另外两个是devicemapper驱动依赖的</p>
<figure class="highlight gml"><table><tr><td class="code"><pre><span class="line">sudo yum install -<span class="symbol">y</span> yum-utils device-mapper-<span class="symbol">persistent</span>-data lvm2</span><br></pre></td></tr></table></figure>
<p>（3）设置yum源为阿里云</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">sudo yum-config-manager --<span class="built_in">add</span>-repo http://mirrors.aliyun.<span class="keyword">com</span>/docker-<span class="keyword">ce</span>/linux/centos/docker-<span class="keyword">ce</span>.repo</span><br></pre></td></tr></table></figure>

<p>（4）安装docker</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">sudo yum <span class="keyword">install</span> docker-ce</span><br></pre></td></tr></table></figure>

<p>（5）安装后查看docker版本</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker -v</span></span><br></pre></td></tr></table></figure>
<h2 id="2-2-设置ustc镜像"><a href="#2-2-设置ustc镜像" class="headerlink" title="2.2 设置ustc镜像"></a>2.2 设置ustc镜像</h2><p>ustc是老牌的linux镜像服务提供者了，还在遥远的ubuntu 5.04版本的时候就在用。ustc的docker镜像加速器速度很快。ustc docker mirror的优势之一就是不需要注册，是真正的公共服务。<br>[<a href="https://lug.ustc.edu.cn/wiki/mirrors/help/docker]" target="_blank" rel="noopener">https://lug.ustc.edu.cn/wiki/mirrors/help/docker]</a><br>修改Docker的配置文件加上这个镜像地址</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">vi <span class="regexp">/etc/</span>docker<span class="regexp">/daemon.json</span></span><br></pre></td></tr></table></figure>

<p>在该文件中输入如下内容：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"registry-mirrors"</span>: [<span class="string">"https://docker.mirrors.ustc.edu.cn"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-3-Docker的启动和停止"><a href="#2-3-Docker的启动和停止" class="headerlink" title="2.3 Docker的启动和停止"></a>2.3 Docker的启动和停止</h2><p>** systemctl**命令是系统服务管理器指令<br>启动docker：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">systemctl <span class="literal">start</span> docker</span><br></pre></td></tr></table></figure>

<p>停止docker：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">stop</span> docker</span><br></pre></td></tr></table></figure>

<p>重启docker：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">systemctl restart docker</span></span><br></pre></td></tr></table></figure>

<p>查看docker状态：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">systemctl status docker</span></span><br></pre></td></tr></table></figure>

<p>开机启动：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">systemctl <span class="builtin-name">enable</span> docker</span><br></pre></td></tr></table></figure>

<p>查看docker概要信息</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker</span> <span class="literal">info</span></span><br></pre></td></tr></table></figure>

<p>查看docker帮助文档</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">docker <span class="comment">--help</span></span><br></pre></td></tr></table></figure>
<h1 id="3-Docker基本命令的使用"><a href="#3-Docker基本命令的使用" class="headerlink" title="3 Docker基本命令的使用"></a>3 Docker基本命令的使用</h1><h2 id="3-1-镜像的相关命令"><a href="#3-1-镜像的相关命令" class="headerlink" title="3.1 镜像的相关命令"></a>3.1 镜像的相关命令</h2><h3 id="3-1-1"><a href="#3-1-1" class="headerlink" title="3.1.1"></a>3.1.1</h3><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker images</span></span><br></pre></td></tr></table></figure>

<p>REPOSITORY：镜像名称</p>
<p>TAG：镜像标签</p>
<p>IMAGE ID：镜像ID</p>
<p>CREATED：镜像的创建日期（不是获取该镜像的日期）</p>
<p>SIZE：镜像大小</p>
<p>这些镜像都是存储在Docker宿主机的/var/lib/docker目录下</p>
<h3 id="3-1-2-搜索镜像"><a href="#3-1-2-搜索镜像" class="headerlink" title="3.1.2 搜索镜像"></a>3.1.2 搜索镜像</h3><p>如果你需要从网络中查找需要的镜像，可以通过以下命令搜索</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">search</span> 镜像名称</span><br></pre></td></tr></table></figure>

<p>NAME：仓库名称</p>
<p>DESCRIPTION：镜像描述</p>
<p>STARS：用户评价，反应一个镜像的受欢迎程度</p>
<p>OFFICIAL：是否官方</p>
<p>AUTOMATED：自动构建，表示该镜像由Docker Hub自动构建流程创建的</p>
<h3 id="3-1-3-拉取镜像"><a href="#3-1-3-拉取镜像" class="headerlink" title="3.1.3 拉取镜像"></a>3.1.3 拉取镜像</h3><p>拉取镜像就是从中央仓库中下载镜像到本地</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker</span> pull 镜像名称</span><br></pre></td></tr></table></figure>

<p>例如，我要下载centos7镜像</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">docker pull centos:<span class="number">7</span></span><br></pre></td></tr></table></figure>
<h3 id="3-1-4-删除镜像"><a href="#3-1-4-删除镜像" class="headerlink" title="3.1.4 删除镜像"></a>3.1.4 删除镜像</h3><p>按镜像ID删除镜像</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker</span> rmi 镜像ID</span><br></pre></td></tr></table></figure>

<p>删除所有镜像</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">docker rmi <span class="string">`docker images -q`</span></span><br></pre></td></tr></table></figure>
<h2 id="3-2容器的相关命令"><a href="#3-2容器的相关命令" class="headerlink" title="3.2容器的相关命令"></a>3.2容器的相关命令</h2><h3 id="3-2-1-查看容器"><a href="#3-2-1-查看容器" class="headerlink" title="3.2.1 查看容器"></a>3.2.1 查看容器</h3><p>查看正在运行的容器</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker ps</span></span><br></pre></td></tr></table></figure>

<p>查看所有容器</p>
<figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"><span class="comment">docker</span> <span class="comment">ps</span> <span class="comment">–a</span></span><br></pre></td></tr></table></figure>

<p>查看最后一次运行的容器</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker</span> ps –l</span><br></pre></td></tr></table></figure>

<p>查看停止的容器</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">docker ps -f <span class="attribute">status</span>=exited</span><br></pre></td></tr></table></figure>
<h3 id="3-2-2-创建与启动容器"><a href="#3-2-2-创建与启动容器" class="headerlink" title="3.2.2 创建与启动容器"></a>3.2.2 创建与启动容器</h3><p>创建容器常用的参数说明：</p>
<p>创建容器命令：docker run</p>
<p> -i：表示运行容器</p>
<p> -t：表示容器启动后会进入其命令行。加入这两个参数后，容器创建就能登录进去。即分配一个伪终端。</p>
<p> –name :为创建的容器命名。</p>
<p> -v：表示目录映射关系（前者是宿主机目录，后者是映射到宿主机上的目录），可以使用多个－v做多个目录或文件映射。注意：最好做目录映射，在宿主机上做修改，然后共享到容器上。</p>
<p> -d：在run后面加上-d参数,则会创建一个守护式容器在后台运行（这样创建容器后不会自动登录容器，如果只加-i -t两个参数，创建后就会自动进去容器）。</p>
<p> -p：表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个-p做多个端口映射</p>
<p>（1）交互式方式创建容器</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">docker <span class="builtin-name">run</span> -it <span class="attribute">--name</span>=容器名称 镜像名称:标签 /bin/bash</span><br></pre></td></tr></table></figure>

<p>这时我们通过ps命令查看，发现可以看到启动的容器，状态为启动状态  </p>
<p>退出当前容器</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="keyword">exit</span></span><br></pre></td></tr></table></figure>
<p>（2）守护式方式创建容器：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">docker <span class="builtin-name">run</span> -di <span class="attribute">--name</span>=容器名称 镜像名称:标签</span><br></pre></td></tr></table></figure>

<p>登录守护式容器方式：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">docker exec -<span class="keyword">it</span> 容器名称 (或者容器ID)  /bin/bash</span><br></pre></td></tr></table></figure>
<h3 id="3-2-3-停止与启动容器"><a href="#3-2-3-停止与启动容器" class="headerlink" title="3.2.3 停止与启动容器"></a>3.2.3 停止与启动容器</h3><p>停止容器：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">docker <span class="keyword">stop</span> 容器名称（或者容器<span class="keyword">ID</span>）</span><br></pre></td></tr></table></figure>

<p>启动容器：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">docker <span class="keyword">start</span> 容器名称（或者容器<span class="keyword">ID</span>）</span><br></pre></td></tr></table></figure>
<h3 id="3-2-4-文件拷贝"><a href="#3-2-4-文件拷贝" class="headerlink" title="3.2.4 文件拷贝"></a>3.2.4 文件拷贝</h3><p>如果我们需要将文件拷贝到容器内可以使用cp命令</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">docker</span> <span class="meta">cp</span> 需要拷贝的文件或目录 容器名称:容器目录</span><br></pre></td></tr></table></figure>

<p>也可以将文件从容器内拷贝出来</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">docker</span> <span class="meta">cp</span> 容器名称:容器目录 需要拷贝的文件或目录</span><br></pre></td></tr></table></figure>

<h3 id="3-2-5-目录挂载"><a href="#3-2-5-目录挂载" class="headerlink" title="3.2.5 目录挂载"></a>3.2.5 目录挂载</h3><p>我们可以在创建容器的时候，将宿主机的目录与容器内的目录进行映射，这样我们就可以通过修改宿主机某个目录的文件从而去影响容器。<br>创建容器 添加-v参数 后边为   宿主机目录:容器目录，例如：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">run</span> -di -v /usr/<span class="keyword">local</span>/myhtml:/usr/<span class="keyword">local</span>/myhtml <span class="comment">--name=mycentos3 centos:7</span></span><br></pre></td></tr></table></figure>

<p>如果你共享的是多级的目录，可能会出现权限不足的提示。</p>
<p>这是因为CentOS7中的安全模块selinux把权限禁掉了，我们需要添加参数  –privileged=true  来解决挂载的目录没有权限的问题</p>
<h3 id="3-2-6-查看容器IP地址"><a href="#3-2-6-查看容器IP地址" class="headerlink" title="3.2.6 查看容器IP地址"></a>3.2.6 查看容器IP地址</h3><p>我们可以通过以下命令查看容器运行的各种数据</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">docker <span class="keyword">inspect</span> 容器名称（容器ID）</span><br></pre></td></tr></table></figure>

<p>也可以直接执行下面的命令直接输出IP地址</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker inspect --format</span>=<span class="string">'&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;'</span> 容器名称（容器ID）</span><br></pre></td></tr></table></figure>
<h3 id="3-2-7-删除容器"><a href="#3-2-7-删除容器" class="headerlink" title="3.2.7 删除容器"></a>3.2.7 删除容器</h3><p>删除指定的容器：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker</span> rm 容器名称（容器ID）</span><br></pre></td></tr></table></figure>
<h1 id="4-应用部署"><a href="#4-应用部署" class="headerlink" title="4 应用部署"></a>4 应用部署</h1><h2 id="4-1-MySQL部署"><a href="#4-1-MySQL部署" class="headerlink" title="4.1 MySQL部署"></a>4.1 MySQL部署</h2><p>（1）拉取mysql镜像</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">docker pull centos/mysql<span class="number">-57</span>-centos7</span><br></pre></td></tr></table></figure>

<p>（2）创建容器</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">docker <span class="builtin-name">run</span> -di <span class="attribute">--name</span>=tensquare_mysql -p 33306:3306 -e <span class="attribute">MYSQL_ROOT_PASSWORD</span>=123456 mysql</span><br></pre></td></tr></table></figure>

<p>-p 代表端口映射，格式为  宿主机映射端口:容器运行端口</p>
<p>-e 代表添加环境变量  MYSQL_ROOT_PASSWORD  是root用户的登陆密码</p>
<p>（3）远程登录mysql</p>
<p>连接宿主机的IP  ,指定端口为33306 </p>
<h2 id="4-2-tomcat部署"><a href="#4-2-tomcat部署" class="headerlink" title="4.2 tomcat部署"></a>4.2 tomcat部署</h2><p>（1）拉取镜像</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">docker pull tomcat:<span class="number">7</span>-jre7</span><br></pre></td></tr></table></figure>

<p>（2）创建容器</p>
<p>创建容器  -p表示地址映射</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">run</span> -di <span class="comment">--name=mytomcat -p 9000:8080 </span></span><br><span class="line">-v /usr/<span class="keyword">local</span>/webapps:/usr/<span class="keyword">local</span>/tomcat/webapps tomcat:<span class="number">7</span>-jre7</span><br></pre></td></tr></table></figure>

<h2 id="4-3-Nginx部署"><a href="#4-3-Nginx部署" class="headerlink" title="4.3 Nginx部署"></a>4.3 Nginx部署</h2><p>（1）拉取镜像    </p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker pull nginx</span></span><br></pre></td></tr></table></figure>

<p>（2）创建Nginx容器</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">docker <span class="builtin-name">run</span> -di <span class="attribute">--name</span>=mynginx -p 80:80 nginx</span><br></pre></td></tr></table></figure>

<h2 id="4-4-Redis部署"><a href="#4-4-Redis部署" class="headerlink" title="4.4 Redis部署"></a>4.4 Redis部署</h2><p>（1）拉取镜像</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker pull redis</span></span><br></pre></td></tr></table></figure>

<p>（2）创建容器</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">docker <span class="builtin-name">run</span> -di <span class="attribute">--name</span>=myredis -p 6379:6379 redis</span><br></pre></td></tr></table></figure>
<h1 id="5-迁移与备份"><a href="#5-迁移与备份" class="headerlink" title="5 迁移与备份"></a>5 迁移与备份</h1><h2 id="5-1-容器保存为镜像"><a href="#5-1-容器保存为镜像" class="headerlink" title="5.1 容器保存为镜像"></a>5.1 容器保存为镜像</h2><p>我们可以通过以下命令将容器保存为镜像</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker commit mynginx mynginx_i</span></span><br></pre></td></tr></table></figure>

<h2 id="5-2-镜像备份"><a href="#5-2-镜像备份" class="headerlink" title="5.2 镜像备份"></a>5.2 镜像备份</h2><p>我们可以通过以下命令将镜像保存为tar 文件</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">docker</span>  <span class="selector-tag">save</span> <span class="selector-tag">-o</span> <span class="selector-tag">mynginx</span><span class="selector-class">.tar</span> <span class="selector-tag">mynginx_i</span></span><br></pre></td></tr></table></figure>

<h2 id="5-3-镜像恢复与迁移"><a href="#5-3-镜像恢复与迁移" class="headerlink" title="5.3 镜像恢复与迁移"></a>5.3 镜像恢复与迁移</h2><p>首先我们先删除掉mynginx_img镜像  然后执行此命令进行恢复</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">docker</span> <span class="selector-tag">load</span> <span class="selector-tag">-i</span> <span class="selector-tag">mynginx</span><span class="selector-class">.tar</span></span><br></pre></td></tr></table></figure>

<p>-i 输入的文件</p>
<p>执行后再次查看镜像，可以看到镜像已经恢复</p>
<h1 id="6-Dockerfile"><a href="#6-Dockerfile" class="headerlink" title="6 Dockerfile"></a>6 Dockerfile</h1><h2 id="6-1-什么是Dockerfile"><a href="#6-1-什么是Dockerfile" class="headerlink" title="6.1 什么是Dockerfile"></a>6.1 什么是Dockerfile</h2><p>Dockerfile是由一系列命令和参数构成的脚本，这些命令应用于基础镜像并最终创建一个新的镜像。</p>
<p>1、对于开发人员：可以为开发团队提供一个完全一致的开发环境；<br>2、对于测试人员：可以直接拿开发时所构建的镜像或者通过Dockerfile文件构建一个新的镜像开始工作了；<br>3、对于运维人员：在部署时，可以实现应用的无缝移植。</p>
<h2 id="6-2-常用命令"><a href="#6-2-常用命令" class="headerlink" title="6.2 常用命令"></a>6.2 常用命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>FROM image_name:tag</td>
<td>定义了使用哪个基础镜像启动构建流程 没有回去自动下载</td>
</tr>
<tr>
<td>MAINTAINER user_name</td>
<td>声明镜像的创建者</td>
</tr>
<tr>
<td>ENV key value</td>
<td>设置环境变量 (可以写多条)</td>
</tr>
<tr>
<td>RUN command</td>
<td>是Dockerfile的核心部分(可以写多条)</td>
</tr>
<tr>
<td>ADD source_dir/file dest_dir/file</td>
<td>将宿主机的文件复制到容器内，如果是一个压缩文件，将会在复制后自动解压</td>
</tr>
<tr>
<td>COPY source_dir/file dest_dir/file</td>
<td>和ADD相似，但是如果有压缩文件并不能解压</td>
</tr>
<tr>
<td>WORKDIR path_dir</td>
<td>设置工作目录</td>
</tr>
</tbody></table>
<h2 id="6-3-使用脚本创建镜像"><a href="#6-3-使用脚本创建镜像" class="headerlink" title="6.3 使用脚本创建镜像"></a>6.3 使用脚本创建镜像</h2><p>步骤：</p>
<p>（1）创建目录</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> –p /usr/<span class="built_in">local</span>/dockerjdk8</span><br></pre></td></tr></table></figure>

<p>（2）下载jdk-8u171-linux-x64.tar.gz并上传到服务器（虚拟机）中的/usr/local/dockerjdk8目录</p>
<p>（3）创建文件Dockerfile  <code>vi Dockerfile</code></p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#依赖镜像名称和ID</span></span><br><span class="line"><span class="keyword">FROM</span> centos:<span class="number">7</span></span><br><span class="line"><span class="comment">#指定镜像创建者信息</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> ITCAST</span><br><span class="line"><span class="comment">#切换工作目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /usr</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir  /usr/<span class="built_in">local</span>/java</span></span><br><span class="line"><span class="comment">#ADD 是相对路径jar,把java添加到容器中</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> jdk-8u171-linux-x64.tar.gz /usr/<span class="built_in">local</span>/java/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#配置java环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_HOME /usr/local/java/jdk1.<span class="number">8.0</span>_171</span><br><span class="line"><span class="keyword">ENV</span> JRE_HOME $JAVA_HOME/jre</span><br><span class="line"><span class="keyword">ENV</span> CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib:$CLASSPATH</span><br><span class="line"><span class="keyword">ENV</span> PATH $JAVA_HOME/bin:$PATH</span><br></pre></td></tr></table></figure>

<p>（4）执行命令构建镜像</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker build -t</span>=<span class="string">'jdk1.8'</span> .</span><br></pre></td></tr></table></figure>

<p>注意后边的空格和点，不要省略</p>
<p>（5）查看镜像是否建立完成</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker images</span></span><br></pre></td></tr></table></figure>
<h1 id="7-Docker私有仓库"><a href="#7-Docker私有仓库" class="headerlink" title="7 Docker私有仓库"></a>7 Docker私有仓库</h1><h2 id="7-1-私有仓库搭建与配置"><a href="#7-1-私有仓库搭建与配置" class="headerlink" title="7.1 私有仓库搭建与配置"></a>7.1 私有仓库搭建与配置</h2><p>（1）拉取私有仓库镜像（此步省略）</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker pull registry</span></span><br></pre></td></tr></table></figure>

<p>（2）启动私有仓库容器</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">docker <span class="builtin-name">run</span> -di <span class="attribute">--name</span>=registry -p 5000:5000 registry</span><br></pre></td></tr></table></figure>

<p>（3）打开浏览器 输入地址<a href="http://192.168.184.141:5000/v2/_catalog看到`{&quot;repositories&quot;:[]}`" target="_blank" rel="noopener">http://192.168.184.141:5000/v2/_catalog看到`{&quot;repositories&quot;:[]}`</a> 表示私有仓库搭建成功并且内容为空</p>
<p>（4）修改daemon.json</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">vi <span class="regexp">/etc/</span>docker<span class="regexp">/daemon.json</span></span><br></pre></td></tr></table></figure>

<p>添加以下内容，保存退出。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"insecure-registries"</span>:[<span class="string">"搭建私服服务器ip:5000"</span>]&#125;</span><br></pre></td></tr></table></figure>

<p>此步用于让 docker信任私有仓库地址</p>
<p>（5）重启docker 服务</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">systemctl restart docker</span></span><br></pre></td></tr></table></figure>
<h2 id="7-2-镜像上传至私有仓库"><a href="#7-2-镜像上传至私有仓库" class="headerlink" title="7.2 镜像上传至私有仓库"></a>7.2 镜像上传至私有仓库</h2><p>（1）标记镜像为私有仓库的镜像</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">docker tag jdk1<span class="number">.8</span> <span class="number">192.168</span><span class="number">.184</span><span class="number">.141</span>:<span class="number">5000</span>/jdk1<span class="number">.8</span></span><br></pre></td></tr></table></figure>

<p>（2）再次启动私服容器</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">docker <span class="literal">start</span> registry</span><br></pre></td></tr></table></figure>

<p>（3）上传标记的镜像和拉取私服镜像</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">docker push <span class="number">192.168</span><span class="number">.184</span><span class="number">.141</span>:<span class="number">5000</span>/jdk1<span class="number">.8</span></span><br><span class="line">docker pull <span class="number">192.168</span><span class="number">.184</span><span class="number">.141</span>:<span class="number">5000</span>/jdk1<span class="number">.8</span>(前提是在需要拉取的服务器docker中加入私服ip地址 vi /etc/docker/daemon.json加入地址)</span><br></pre></td></tr></table></figure>
<h2 id="7-3-部署微服务"><a href="#7-3-部署微服务" class="headerlink" title="7.3 部署微服务"></a>7.3 部署微服务</h2><ul>
<li><p>部署方式有两种</p>
</li>
<li><p>第一种是打成jar包发送到服务器然后书写dockerfile然后根据它们两个 执行build来生成镜像</p>
 <figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker build -t</span>=<span class="string">'镜像名'</span></span><br></pre></td></tr></table></figure>

<ul>
<li>注意的是dockerfile的基础镜像需要安装了jdk1.8的centos镜像</li>
<li>使用maven打包springboot必须有springboot-maven插件如果没有也可以打包但是生成的jar包无法使用 java -jar运行。</li>
</ul>
</li>
<li><p>第二种就是idea集成docker来部署(推荐使用因为每次上传jar这种方式无疑是麻烦的)</p>
<ul>
<li>开启docker服务器的远程连接<br>首先需要docker-maven插件加入配置信息(镜像名什么的服务器名),因为使用的是java11,在此之后的版本失去了activity内置在jdk里面的包所以要加坐标依赖,在src下建docker文件夹写dockerfile文件,这样就能远程连接生成镜像了。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
  </entry>
</search>
